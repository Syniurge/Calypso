// RUN: %ldc -cpp-args -std=c++11 -cpp-cachedir=%t.cache -of %t %s
// RUN: %t > %t.out
// R_N: FileCheck %s < %t.out

/**
 * Basic tests for Calypso.
 *
 * Build with:
 *   $ ldc2 -cpp-args -std=c++11 basics.d
 */

pragma (cppmap, "basics.hpp");
pragma (cppmap, "basics.cpp");
    // « cppmap » is a new pragma introduced to specify the C/C++ headers.
    // It tells Clang to parse the headers but doesn't import anything.

import std.stdio, std.conv, std.string;
import (C++) test.testStruct; // imports test::testStruct
import (C++) test.testClass; // imports test::testClass
import (C++) test.testInherit; // etc. each struct/class/enum template or not is placed in a module named after it
import (C++) test.tempWithPartialSpecs; // imports the primary class template as well as all its partial and explicit specializations
import (C++) test.anotherClass, test.testMultipleInherit,
             test.enumTest, test.arrayOfTen;
import (C++) test._; // « _ » is a special module that contains every global variable, global function
                // and typedef of a namespace.

class testDClass
{
public:
    testStruct mycstruct;
    int test;

    this()
    {
        test = 78;
        mycstruct.f = 6.12;
        mycstruct.c = 'p';
    }
}

// D class inheriting from a C++ class, incl. methods overriding virtual C++ methods
// Calypso generates a new C++ vtable with thunk functions that makes them callable from C++ through the base method.
//
// The resulting "hybrid" class holds pointers to the 2 different kinds of vtable, the D one and the C++ one(s).
class DCXXclass : testMultipleInherit
{
public:
    uint someUint = 9;

    extern (C++) override const (char)* hello(bool ceres)
    {
        if (ceres && someUint > 5)
            return "Hello Ceres";

        return "Hello Pluto";
    }
}

void main()
{
    std.stdio.writeln("[Simple C++ function call test]");
    writeln("testFunc('a') = ", testFunc('a'));
    writeln("testFunc('b') = ", testFunc('b'));
    writeln("testFunc('c') = ", testFunc('c'));

    // Global variables
    std.stdio.writeln("\n[Global variables]");
    writeln("testDoubleVar = ", testDoubleVar);

    writeln("testVar.f = ", testVar.f);
    writeln("testVar.c = ", testVar.c);
    writeln("testVar.n = ", testVar.n);

    // Structs
    std.stdio.writeln("\n[Structs]");
    testStruct cs;
    cs.f = 1.56;
    cs.c = 'x';
    writeln("cs.f = ", cs.f);
    writeln("cs.c = ", cs.c);

    // D class with a C struct member
    std.stdio.writeln("\n[D class with a C struct member]");
    auto dd = new testDClass;
    dd.mycstruct.f = 9.51;
    dd.mycstruct.c = 'o';
    writeln("dd.mycstruct.f = ", dd.mycstruct.f);

    // Classes: multiple inheritance, static downcasts
    std.stdio.writeln("\n[Classes: multiple inheritance, static downcasts]");
    testClass *cls = new testInherit;
    cls.priv.f = 5.25;
    writeln("cls.priv.f = ", cls.priv.f);
    writeln("cls.echo(9, 8) = ", cls.echo(9, 8)); // 42 * 5 == 210 expected if the ctor was called
    writeln("cls.echo2(2.5) = ", cls.echo2(2.5));

    auto mul = new testMultipleInherit;
    mul.pointerToStruct = &cs;
    writeln("mul.pointerToStruct = ", mul.pointerToStruct);
    writeln("mul.hello(false) = ", to!string(mul.hello(false)));

    anotherClass* ano = new testMultipleInherit;
    writeln("ano.hello(true) = ", to!string(ano.hello(true)));

    // Hybrid D-C++ classes
    std.stdio.writeln("\n[Hybrid D-C++ classes]");
    auto isThisRealLife = new DCXXclass;
    isThisRealLife.someUint = 1234;
    writeln("isThisRealLife.someUint = ", isThisRealLife.someUint);
    isThisRealLife.pointerToStruct = &cs;
    writeln("isThisRealLife.pointerToStruct = ", isThisRealLife.pointerToStruct);
    writeln("isThisRealLife.hello(true) = ", to!string(isThisRealLife.hello(true)));

    // Downcasting to the C++ base class to check the C++ vtable generated by Calypso
    std.stdio.writeln("\n[Downcasting to the C++ base class, checking the C++ vtable generated by Calypso]");
    testMultipleInherit* testCast = isThisRealLife;
    writeln("testCast.hello(true) = ", to!string(testCast.hello(true)));
    writeln("testCast.echo2() = ", testCast.echo2(3));

    // Enums
    std.stdio.writeln("\n[Enums]");
    enumTest someEnumValue = enumTest.ENUM_SOMEVAL;
    writeln("someEnumValue = ", someEnumValue);

    // Class templates and arrays
    std.stdio.writeln("\n[Class templates and arrays]");
    auto amIAValue = new arrayOfTen!char;
    amIAValue.someArray[4] = 'h';
    writeln("amIAValue.FifthChar() = ", amIAValue.FifthChar());

    // Partial and explicit class template specializations
    std.stdio.writeln("\n[Partial and explicit class template specializations]");
    auto t1 = new tempWithPartialSpecs!(double, 10);
    auto t2 = new tempWithPartialSpecs!(char, 8);
    auto t3 = new tempWithPartialSpecs!(bool, 5);
    writeln("t1 instantied from ", to!string(t1.toChars));
    writeln("t2 instantied from ", to!string(t2.toChars));
    writeln("t3 instantied from ", to!string(t3.toChars));

    // Function templates
    std.stdio.writeln("\n[Function templates]");
    char _char;
    short _short;
    double _double;
    testStruct _testStruct;
    writeln("funcTempSizeOf(_char) = ", funcTempSizeOf(_char));
    writeln("funcTempSizeOf(_short) = ", funcTempSizeOf(_short));
    writeln("funcTempSizeOf(_double) = ", funcTempSizeOf(_double));
    writeln("funcTempSizeOf(_testStruct) = ", funcTempSizeOf(_testStruct));
}
