// Automatically generated by gen_ddmdstructor

#include "expression.h"

class Tuple;

RootObject* new_RootObject();
Tuple* new_Tuple();
StoppableVisitor* new_StoppableVisitor();
Dsymbol* new_Dsymbol();
Dsymbol* new_Dsymbol(Identifier *arg0);
ScopeDsymbol* new_ScopeDsymbol();
ScopeDsymbol* new_ScopeDsymbol(Identifier *id);
WithScopeSymbol* new_WithScopeSymbol(WithStatement *withstate);
ArrayScopeSymbol* new_ArrayScopeSymbol(Scope *sc, Expression *e);
ArrayScopeSymbol* new_ArrayScopeSymbol(Scope *sc, TypeTuple *t);
ArrayScopeSymbol* new_ArrayScopeSymbol(Scope *sc, TupleDeclaration *td);
OverloadSet* new_OverloadSet(Identifier *ident, OverloadSet *os);
DsymbolTable* new_DsymbolTable();
Identifier* new_Identifier(const char *_string, unsigned long length, int value);
Expression* new_Expression(const Loc& loc, TOK op, int size);
IntegerExp* new_IntegerExp(const Loc& loc, dinteger_t value, Type *type);
IntegerExp* new_IntegerExp(dinteger_t value);
ErrorExp* new_ErrorExp();
RealExp* new_RealExp(const Loc& loc, real_t value, Type *type);
ComplexExp* new_ComplexExp(const Loc& loc, complex_t value, Type *type);
IdentifierExp* new_IdentifierExp(const Loc& loc, Identifier *ident);
DollarExp* new_DollarExp(const Loc& loc);
DsymbolExp* new_DsymbolExp(const Loc& loc, Dsymbol *s, bool hasOverloads);
ThisExp* new_ThisExp(const Loc& loc);
SuperExp* new_SuperExp(const Loc& loc);
NullExp* new_NullExp(const Loc& loc, Type *t = nullptr);
StringExp* new_StringExp(const Loc& loc, char *s);
StringExp* new_StringExp(const Loc& loc, void *s, size_t len);
StringExp* new_StringExp(const Loc& loc, void *s, size_t len, utf8_t postfix);
TupleExp* new_TupleExp(const Loc& loc, Expression *e0, Expressions *exps);
TupleExp* new_TupleExp(const Loc& loc, Expressions *exps);
TupleExp* new_TupleExp(const Loc& loc, TupleDeclaration *tup);
ArrayLiteralExp* new_ArrayLiteralExp(const Loc& loc, Type *type, Expressions *elements);
ArrayLiteralExp* new_ArrayLiteralExp(const Loc& loc, Type *type, Expression *e);
ArrayLiteralExp* new_ArrayLiteralExp(const Loc& loc, Type *type, Expression *basis, Expressions *elements);
AssocArrayLiteralExp* new_AssocArrayLiteralExp(const Loc& loc, Expressions *keys, Expressions *values);
StructLiteralExp* new_StructLiteralExp(const Loc& loc, AggregateDeclaration *sd, Expressions *elements, Type *stype);
TypeExp* new_TypeExp(const Loc& loc, Type *type);
ScopeExp* new_ScopeExp(const Loc& loc, ScopeDsymbol *sds);
TemplateExp* new_TemplateExp(const Loc& loc, TemplateDeclaration *td, FuncDeclaration *fd = nullptr);
NewExp* new_NewExp(const Loc& loc, Expression *thisexp, Expressions *newargs, Type *newtype, Expressions *arguments);
NewAnonClassExp* new_NewAnonClassExp(const Loc& loc, Expression *thisexp, Expressions *newargs, ClassDeclaration *cd, Expressions *arguments);
SymbolExp* new_SymbolExp(const Loc& loc, TOK op, int size, Declaration *var, bool hasOverloads);
SymOffExp* new_SymOffExp(const Loc& loc, Declaration *var, dinteger_t offset, bool hasOverloads);
VarExp* new_VarExp(const Loc& loc, Declaration *var, bool hasOverloads = true);
OverExp* new_OverExp(const Loc& loc, OverloadSet *s);
FuncExp* new_FuncExp(const Loc& loc, Dsymbol *s);
DeclarationExp* new_DeclarationExp(const Loc& loc, Dsymbol *declaration);
TypeidExp* new_TypeidExp(const Loc& loc, RootObject *obj);
TraitsExp* new_TraitsExp(const Loc& loc, Identifier *ident, Objects *args);
HaltExp* new_HaltExp(const Loc& loc);
IsExp* new_IsExp(const Loc& loc, Type *targ, Identifier *id, TOK tok, Type *tspec, TOK tok2, TemplateParameters *parameters);
BinAssignExp* new_BinAssignExp(const Loc& loc, TOK op, int size, Expression *e1, Expression *e2);
CompileExp* new_CompileExp(const Loc& loc, Expressions *exps);
ImportExp* new_ImportExp(const Loc& loc, Expression *e);
AssertExp* new_AssertExp(const Loc& loc, Expression *e, Expression *msg);
DotIdExp* new_DotIdExp(const Loc& loc, Expression *e, Identifier *ident);
DotTemplateExp* new_DotTemplateExp(const Loc& loc, Expression *e, TemplateDeclaration *td);
DotVarExp* new_DotVarExp(const Loc& loc, Expression *e, Declaration *var, bool hasOverloads = true);
DotTemplateInstanceExp* new_DotTemplateInstanceExp(const Loc& loc, Expression *e, Identifier *name, Objects *tiargs);
DotTemplateInstanceExp* new_DotTemplateInstanceExp(const Loc& loc, Expression *e, TemplateInstance *ti);
DelegateExp* new_DelegateExp(const Loc& loc, Expression *e, FuncDeclaration *func, bool hasOverloads);
DotTypeExp* new_DotTypeExp(const Loc& loc, Expression *e, Dsymbol *sym);
CallExp* new_CallExp(const Loc& loc, Expression *e, Expressions *exps);
CallExp* new_CallExp(const Loc& loc, Expression *e);
CallExp* new_CallExp(const Loc& loc, Expression *e, Expression *earg1);
CallExp* new_CallExp(const Loc& loc, Expression *e, Expression *earg1, Expression *earg2);
AddrExp* new_AddrExp(const Loc& loc, Expression *e);
PtrExp* new_PtrExp(const Loc& loc, Expression *e);
PtrExp* new_PtrExp(const Loc& loc, Expression *e, Type *t);
NegExp* new_NegExp(const Loc& loc, Expression *e);
UAddExp* new_UAddExp(const Loc& loc, Expression *e);
ComExp* new_ComExp(const Loc& loc, Expression *e);
NotExp* new_NotExp(const Loc& loc, Expression *e);
DeleteExp* new_DeleteExp(const Loc& loc, Expression *e, bool isRAII);
CastExp* new_CastExp(const Loc& loc, Expression *e, Type *t);
CastExp* new_CastExp(const Loc& loc, Expression *e, unsigned char mod);
VectorExp* new_VectorExp(const Loc& loc, Expression *e, Type *t);
SliceExp* new_SliceExp(const Loc& loc, Expression *e1, IntervalExp *ie);
SliceExp* new_SliceExp(const Loc& loc, Expression *e1, Expression *lwr, Expression *upr);
ArrayLengthExp* new_ArrayLengthExp(const Loc& loc, Expression *e1);
IntervalExp* new_IntervalExp(const Loc& loc, Expression *lwr, Expression *upr);
DelegatePtrExp* new_DelegatePtrExp(const Loc& loc, Expression *e1);
DelegateFuncptrExp* new_DelegateFuncptrExp(const Loc& loc, Expression *e1);
ArrayExp* new_ArrayExp(const Loc& loc, Expression *e1, Expression *index);
ArrayExp* new_ArrayExp(const Loc& loc, Expression *e1, Expressions *args);
DotExp* new_DotExp(const Loc& loc, Expression *e1, Expression *e2);
CommaExp* new_CommaExp(const Loc& loc, Expression *e1, Expression *e2);
IndexExp* new_IndexExp(const Loc& loc, Expression *e1, Expression *e2);
PostExp* new_PostExp(TOK op, const Loc& loc, Expression *e);
PreExp* new_PreExp(TOK op, const Loc& loc, Expression *e);
AssignExp* new_AssignExp(const Loc& loc, Expression *e1, Expression *e2);
ConstructExp* new_ConstructExp(const Loc& loc, Expression *e1, Expression *e2);
ConstructExp* new_ConstructExp(const Loc& loc, VarDeclaration *v, Expression *e2);
BlitExp* new_BlitExp(const Loc& loc, Expression *e1, Expression *e2);
BlitExp* new_BlitExp(const Loc& loc, VarDeclaration *v, Expression *e2);
AddAssignExp* new_AddAssignExp(const Loc& loc, Expression *e1, Expression *e2);
MinAssignExp* new_MinAssignExp(const Loc& loc, Expression *e1, Expression *e2);
MulAssignExp* new_MulAssignExp(const Loc& loc, Expression *e1, Expression *e2);
DivAssignExp* new_DivAssignExp(const Loc& loc, Expression *e1, Expression *e2);
ModAssignExp* new_ModAssignExp(const Loc& loc, Expression *e1, Expression *e2);
AndAssignExp* new_AndAssignExp(const Loc& loc, Expression *e1, Expression *e2);
OrAssignExp* new_OrAssignExp(const Loc& loc, Expression *e1, Expression *e2);
XorAssignExp* new_XorAssignExp(const Loc& loc, Expression *e1, Expression *e2);
PowAssignExp* new_PowAssignExp(const Loc& loc, Expression *e1, Expression *e2);
ShlAssignExp* new_ShlAssignExp(const Loc& loc, Expression *e1, Expression *e2);
ShrAssignExp* new_ShrAssignExp(const Loc& loc, Expression *e1, Expression *e2);
UshrAssignExp* new_UshrAssignExp(const Loc& loc, Expression *e1, Expression *e2);
CatAssignExp* new_CatAssignExp(const Loc& loc, Expression *e1, Expression *e2);
AddExp* new_AddExp(const Loc& loc, Expression *e1, Expression *e2);
MinExp* new_MinExp(const Loc& loc, Expression *e1, Expression *e2);
CatExp* new_CatExp(const Loc& loc, Expression *e1, Expression *e2);
MulExp* new_MulExp(const Loc& loc, Expression *e1, Expression *e2);
DivExp* new_DivExp(const Loc& loc, Expression *e1, Expression *e2);
ModExp* new_ModExp(const Loc& loc, Expression *e1, Expression *e2);
PowExp* new_PowExp(const Loc& loc, Expression *e1, Expression *e2);
ShlExp* new_ShlExp(const Loc& loc, Expression *e1, Expression *e2);
ShrExp* new_ShrExp(const Loc& loc, Expression *e1, Expression *e2);
UshrExp* new_UshrExp(const Loc& loc, Expression *e1, Expression *e2);
AndExp* new_AndExp(const Loc& loc, Expression *e1, Expression *e2);
OrExp* new_OrExp(const Loc& loc, Expression *e1, Expression *e2);
XorExp* new_XorExp(const Loc& loc, Expression *e1, Expression *e2);
LogicalExp* new_LogicalExp(const Loc& loc, TOK op, Expression *e1, Expression *e2);
CmpExp* new_CmpExp(TOK op, const Loc& loc, Expression *e1, Expression *e2);
InExp* new_InExp(const Loc& loc, Expression *e1, Expression *e2);
RemoveExp* new_RemoveExp(const Loc& loc, Expression *e1, Expression *e2);
EqualExp* new_EqualExp(TOK op, const Loc& loc, Expression *e1, Expression *e2);
IdentityExp* new_IdentityExp(TOK op, const Loc& loc, Expression *e1, Expression *e2);
CondExp* new_CondExp(const Loc& loc, Expression *econd, Expression *e1, Expression *e2);
DefaultInitExp* new_DefaultInitExp(const Loc& loc, TOK subop, int size);
FileInitExp* new_FileInitExp(const Loc& loc, TOK tok);
LineInitExp* new_LineInitExp(const Loc& loc);
ModuleInitExp* new_ModuleInitExp(const Loc& loc);
FuncInitExp* new_FuncInitExp(const Loc& loc);
PrettyFuncInitExp* new_PrettyFuncInitExp(const Loc& loc);
TypeError* new_TypeError();
TypeBasic* new_TypeBasic(TY ty);
TypeVector* new_TypeVector(Type *basetype);
TypeSArray* new_TypeSArray(Type *t, Expression *dim);
TypeDArray* new_TypeDArray(Type *t);
TypeAArray* new_TypeAArray(Type *t, Type *index);
TypePointer* new_TypePointer(Type *t);
TypeReference* new_TypeReference(Type *t);
TypeFunction* new_TypeFunction(ParameterList pl, Type *treturn, LINK linkage, StorageClass stc = 0);
TypeDelegate* new_TypeDelegate(Type *t);
TypeIdentifier* new_TypeIdentifier(const Loc& loc, Identifier *ident);
TypeInstance* new_TypeInstance(const Loc& loc, TemplateInstance *tempinst);
TypeTypeof* new_TypeTypeof(const Loc& loc, Expression *exp);
TypeReturn* new_TypeReturn(const Loc& loc);
TypeStruct* new_TypeStruct(StructDeclaration *sym);
TypeEnum* new_TypeEnum(EnumDeclaration *sym);
TypeClass* new_TypeClass(ClassDeclaration *sym);
TypeTuple* new_TypeTuple(Parameters *arguments);
TypeTuple* new_TypeTuple(Expressions *exps);
TypeTuple* new_TypeTuple();
TypeTuple* new_TypeTuple(Type *t1);
TypeTuple* new_TypeTuple(Type *t1, Type *t2);
TypeSlice* new_TypeSlice(Type *next, Expression *lwr, Expression *upr);
TypeNull* new_TypeNull();
Parameter* new_Parameter(StorageClass storageClass, Type *type, Identifier *ident, Expression *defaultArg, UserAttributeDeclaration* userAttribDecl);
TupleDeclaration* new_TupleDeclaration(const Loc& loc, Identifier *ident, Objects *objects);
AliasDeclaration* new_AliasDeclaration(const Loc& loc, Identifier *ident, Type *type);
AliasDeclaration* new_AliasDeclaration(const Loc& loc, Identifier *ident, Dsymbol *s);
OverDeclaration* new_OverDeclaration(Identifier *ident, Dsymbol *s, bool hasOverloads);
VarDeclaration* new_VarDeclaration(const Loc& loc, Type *t, Identifier *id, Initializer *init);
SymbolDeclaration* new_SymbolDeclaration(const Loc& loc, StructDeclaration *dsym);
TypeInfoDeclaration* new_TypeInfoDeclaration(Type *tinfo);
TypeInfoStructDeclaration* new_TypeInfoStructDeclaration(Type *tinfo);
TypeInfoClassDeclaration* new_TypeInfoClassDeclaration(Type *tinfo);
TypeInfoInterfaceDeclaration* new_TypeInfoInterfaceDeclaration(Type *tinfo);
TypeInfoPointerDeclaration* new_TypeInfoPointerDeclaration(Type *tinfo);
TypeInfoArrayDeclaration* new_TypeInfoArrayDeclaration(Type *tinfo);
TypeInfoStaticArrayDeclaration* new_TypeInfoStaticArrayDeclaration(Type *tinfo);
TypeInfoAssociativeArrayDeclaration* new_TypeInfoAssociativeArrayDeclaration(Type *tinfo);
TypeInfoEnumDeclaration* new_TypeInfoEnumDeclaration(Type *tinfo);
TypeInfoFunctionDeclaration* new_TypeInfoFunctionDeclaration(Type *tinfo);
TypeInfoDelegateDeclaration* new_TypeInfoDelegateDeclaration(Type *tinfo);
TypeInfoTupleDeclaration* new_TypeInfoTupleDeclaration(Type *tinfo);
TypeInfoConstDeclaration* new_TypeInfoConstDeclaration(Type *tinfo);
TypeInfoInvariantDeclaration* new_TypeInfoInvariantDeclaration(Type *tinfo);
TypeInfoSharedDeclaration* new_TypeInfoSharedDeclaration(Type *tinfo);
TypeInfoWildDeclaration* new_TypeInfoWildDeclaration(Type *tinfo);
TypeInfoVectorDeclaration* new_TypeInfoVectorDeclaration(Type *tinfo);
ThisDeclaration* new_ThisDeclaration(const Loc& loc, Type *t);
FuncDeclaration* new_FuncDeclaration(const Loc& loc, const Loc& endloc, Identifier *id, StorageClass storage_class, Type *type);
FuncAliasDeclaration* new_FuncAliasDeclaration(Identifier *ident, FuncDeclaration *funcalias, bool hasOverloads);
FuncLiteralDeclaration* new_FuncLiteralDeclaration(const Loc& loc, const Loc& endloc, Type *type, TOK tok, ForeachStatement *fes, Identifier *id);
CtorDeclaration* new_CtorDeclaration(const Loc& loc, const Loc& endloc, StorageClass stc, Type *type);
PostBlitDeclaration* new_PostBlitDeclaration(const Loc& loc, const Loc& endloc, StorageClass stc, Identifier *id);
DtorDeclaration* new_DtorDeclaration(const Loc& loc, const Loc& endloc);
DtorDeclaration* new_DtorDeclaration(const Loc& loc, const Loc& endloc, StorageClass stc, Identifier *id);
StaticCtorDeclaration* new_StaticCtorDeclaration(const Loc& loc, const Loc& endloc, StorageClass stc);
SharedStaticCtorDeclaration* new_SharedStaticCtorDeclaration(const Loc& loc, const Loc& endloc, StorageClass stc);
StaticDtorDeclaration* new_StaticDtorDeclaration(const Loc& loc, const Loc& endloc, StorageClass stc);
SharedStaticDtorDeclaration* new_SharedStaticDtorDeclaration(const Loc& loc, const Loc& endloc, StorageClass stc);
UnitTestDeclaration* new_UnitTestDeclaration(const Loc& loc, const Loc& endloc, StorageClass stc, char *codedoc);
DeleteDeclaration* new_DeleteDeclaration(const Loc& loc, const Loc& endloc, StorageClass stc, Parameters *arguments);
StructDeclaration* new_StructDeclaration(const Loc& loc, Identifier *id, bool inObject = false);
UnionDeclaration* new_UnionDeclaration(const Loc& loc, Identifier *id);
InterfaceDeclaration* new_InterfaceDeclaration(const Loc& loc, Identifier *id, BaseClasses *baseclasses);
DVCondition* new_DVCondition(Module *mod, unsigned int level, Identifier *ident);
DebugCondition* new_DebugCondition(Module *mod, unsigned int level, Identifier *ident);
VersionCondition* new_VersionCondition(Module *mod, unsigned int level, Identifier *ident);
StaticIfCondition* new_StaticIfCondition(const Loc& loc, Expression *exp);
EnumDeclaration* new_EnumDeclaration(const Loc& loc, Identifier *id, Type *memtype);
EnumMember* new_EnumMember(const Loc& loc, Identifier *id, Expression *value, Type *origType);
Import* new_Import(const Loc& loc, Identifiers *packages, Identifier *id, Identifier *aliasId, int isstatic);
VoidInitializer* new_VoidInitializer(const Loc& loc);
ErrorInitializer* new_ErrorInitializer();
StructInitializer* new_StructInitializer(const Loc& loc);
ArrayInitializer* new_ArrayInitializer(const Loc& loc);
ExpInitializer* new_ExpInitializer(const Loc& loc, Expression *exp);
Package* new_Package(const Loc& loc, Identifier *ident);
ErrorStatement* new_ErrorStatement();
PeelStatement* new_PeelStatement(Statement *s);
ExpStatement* new_ExpStatement(const Loc& loc, Expression *exp);
ExpStatement* new_ExpStatement(const Loc& loc, Dsymbol *s);
DtorExpStatement* new_DtorExpStatement(const Loc& loc, Expression *exp, VarDeclaration *v);
CompileStatement* new_CompileStatement(const Loc& loc, Expression *exp);
CompoundStatement* new_CompoundStatement(const Loc& loc, Statements *s);
CompoundStatement* new_CompoundStatement(const Loc& loc, Statement *s1);
CompoundStatement* new_CompoundStatement(const Loc& loc, Statement *s1, Statement *s2);
CompoundDeclarationStatement* new_CompoundDeclarationStatement(const Loc& loc, Statements *s);
UnrolledLoopStatement* new_UnrolledLoopStatement(const Loc& loc, Statements *statements);
WhileStatement* new_WhileStatement(const Loc& loc, Expression *c, Statement *b, const Loc& endloc);
ForStatement* new_ForStatement(const Loc& loc, Statement *init, Expression *condition, Expression *increment, Statement *_body, const Loc& endloc);
ForeachStatement* new_ForeachStatement(const Loc& loc, TOK op, Parameters *parameters, Expression *aggr, Statement *_body, const Loc& endloc);
ForeachRangeStatement* new_ForeachRangeStatement(const Loc& loc, TOK op, Parameter *prm, Expression *lwr, Expression *upr, Statement *_body, const Loc& endloc);
ConditionalStatement* new_ConditionalStatement(const Loc& loc, Condition *condition, Statement *ifbody, Statement *elsebody);
PragmaStatement* new_PragmaStatement(const Loc& loc, Identifier *ident, Expressions *args, Statement *_body);
StaticAssertStatement* new_StaticAssertStatement(StaticAssert *sa);
SwitchStatement* new_SwitchStatement(const Loc& loc, Expression *c, Statement *b, bool isFinal);
CaseStatement* new_CaseStatement(const Loc& loc, Expression *exp, Statement *s);
CaseRangeStatement* new_CaseRangeStatement(const Loc& loc, Expression *first, Expression *last, Statement *s);
DefaultStatement* new_DefaultStatement(const Loc& loc, Statement *s);
GotoDefaultStatement* new_GotoDefaultStatement(const Loc& loc);
GotoCaseStatement* new_GotoCaseStatement(const Loc& loc, Expression *exp);
SwitchErrorStatement* new_SwitchErrorStatement(const Loc& loc);
ReturnStatement* new_ReturnStatement(const Loc& loc, Expression *exp);
BreakStatement* new_BreakStatement(const Loc& loc, Identifier *ident);
ContinueStatement* new_ContinueStatement(const Loc& loc, Identifier *ident);
SynchronizedStatement* new_SynchronizedStatement(const Loc& loc, Expression *exp, Statement *_body);
TryCatchStatement* new_TryCatchStatement(const Loc& loc, Statement *_body, Catches *catches);
Catch* new_Catch(const Loc& loc, Type *t, Identifier *id, Statement *handler);
TryFinallyStatement* new_TryFinallyStatement(const Loc& loc, Statement *_body, Statement *finalbody);
ThrowStatement* new_ThrowStatement(const Loc& loc, Expression *exp);
DebugStatement* new_DebugStatement(const Loc& loc, Statement *statement);
GotoStatement* new_GotoStatement(const Loc& loc, Identifier *ident);
LabelStatement* new_LabelStatement(const Loc& loc, Identifier *ident, Statement *statement);
LabelDsymbol* new_LabelDsymbol(Identifier *ident);
AsmStatement* new_AsmStatement(const Loc& loc, Token *tokens);
CompoundAsmStatement* new_CompoundAsmStatement(const Loc& loc, Statements *s, StorageClass stc);
ImportStatement* new_ImportStatement(const Loc& loc, Dsymbols *imports);
StaticAssert* new_StaticAssert(const Loc& loc, Expression *exp, Expression *msg);
TemplateDeclaration* new_TemplateDeclaration(const Loc& loc, Identifier *id, TemplateParameters *parameters, Expression *constraint, Dsymbols *decldefs, bool ismixin = false, bool literal = false);
TemplateTypeParameter* new_TemplateTypeParameter(const Loc& loc, Identifier *ident, Type *specType, Type *defaultType);
TemplateThisParameter* new_TemplateThisParameter(const Loc& loc, Identifier *ident, Type *specType, Type *defaultType);
TemplateValueParameter* new_TemplateValueParameter(const Loc& loc, Identifier *ident, Type *valType, Expression *specValue, Expression *defaultValue);
TemplateAliasParameter* new_TemplateAliasParameter(const Loc& loc, Identifier *ident, Type *specType, RootObject *specAlias, RootObject *defaultAlias);
TemplateTupleParameter* new_TemplateTupleParameter(const Loc& loc, Identifier *ident);
TemplateInstance* new_TemplateInstance(const Loc& loc, Identifier *ident, Objects *tiargs);
TemplateInstance* new_TemplateInstance(const Loc& loc, TemplateDeclaration *td, Objects *tiargs);
TemplateMixin* new_TemplateMixin(const Loc& loc, Identifier *ident, TypeQualified *tqual, Objects *tiargs);
LinkDeclaration* new_LinkDeclaration(LINK p, Dsymbols *decl);

LangPlugins* new_LangPlugins();

void delete_Object(RootObject *o);
void delete_File(File* o);

void construct_TypeBasic(TypeBasic* _this, TY ty);
void construct_TypePointer(TypePointer* _this, Type* t);
void construct_TypeReference(TypeReference* _this, Type* t);
void construct_VarDeclaration(VarDeclaration *_this, const Loc& loc, Type *t, Identifier *id, Initializer *init);
void construct_FuncDeclaration(FuncDeclaration *_this, const Loc& loc, const Loc& endloc, Identifier *id, StorageClass storage_class, Type *type);
void construct_CtorDeclaration(CtorDeclaration *_this, const Loc& loc, const Loc& endloc, StorageClass stc, Type *type);
void construct_DtorDeclaration(DtorDeclaration *_this, const Loc& loc, const Loc& endloc, StorageClass stc, Identifier *id);
void construct_EnumDeclaration(EnumDeclaration *_this, const Loc& loc, Identifier *id, Type *memtype);
void construct_EnumMember(EnumMember *_this, const Loc& loc, Identifier *id, Expression *value, Type *origType);
void construct_AliasDeclaration(AliasDeclaration *_this, const Loc& loc, Identifier *ident, Type *type);
void construct_Import(Import *_this, const Loc& loc, Identifiers *packages, Identifier *id, Identifier *aliasId, int isstatic);
void construct_StructDeclaration(StructDeclaration *_this, const Loc& loc, Identifier *id, bool inObject = false);
void construct_UnionDeclaration(UnionDeclaration *_this, const Loc& loc, Identifier *id);
void construct_ClassDeclaration(ClassDeclaration *_this, const Loc& loc, Identifier *id, BaseClasses *baseclasses, Dsymbols* members, bool inObject = false);
void construct_AnonDeclaration(AnonDeclaration *_this, const Loc& loc, bool isunion, Dsymbols *decl);
void construct_Catch(Catch *_this, const Loc& loc, Type *t, Identifier *id, Statement *handler);
void construct_Module(Module *_this, const Loc& loc, const char *arg, Identifier *ident, int doDocComment, int doHdrGen);
void construct_TemplateDeclaration(TemplateDeclaration *_this, const Loc& loc, Identifier *id, TemplateParameters *parameters, Expression *constraint, Dsymbols *decldefs, bool ismixin = false, bool literal = false);
void construct_TemplateInstance(TemplateInstance *_this, const Loc& loc, Identifier *ident, Objects* tiargs);
void construct_TemplateInstance(TemplateInstance *_this, const Loc& loc, TemplateDeclaration *td, Objects *tiargs);
